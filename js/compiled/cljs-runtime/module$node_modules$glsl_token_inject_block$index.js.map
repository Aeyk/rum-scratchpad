{
"version":3,
"file":"module$node_modules$glsl_token_inject_block$index.js",
"lineCount":2,
"mappings":"AAAAA,cAAA,CAAe,iDAAf,CAAsE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAC9GD,MAAA,CAAOC,OAAP,CAKAC,QAAyB,CAACC,MAAD,CAASC,SAAT,CAAoB,CACtCC,KAAA,CAAMC,OAAN,CAAcF,SAAd,CAAL,GACEA,SADF,CACc,CAAEA,SAAF,CADd,CAkBIG,KAAAA,MAAQ,EACZ,KAAK,IAAIC,EAAI,CAAb,CAAgBA,CAAhB,CAjB0BL,MAiB1B,CAA2BM,MAA3B,CAAmCD,CAAA,EAAnC,CAAwC,CACtC,IAAIE,MAlBoBP,MAkBZ,CAAOK,CAAP,CACZ,IAAmB,cAAnB,GAAIE,KAAJ,CAAUC,IAAV,CACM,uBAAA,CAAwBC,IAAxB,CAA6BF,KAA7B,CAAmCG,IAAnC,CAAJ,GACEN,KADF,CACUO,IAAA,CAAKC,GAAL,CAASR,KAAT,CAAgBC,CAAhB,CADV,CADF,KAIO,IAAmB,SAAnB,GAAIE,KAAJ,CAAUC,IAAV,EAA+C,WAA/C,GAAgCD,KAAhC,CAAsCG,IAAtC,CAA4D,CAW5B,CAAA,CAAA,CACzC,IAASL,KAAT,CAXyCA,CAWzC,CAAoBA,KAApB,CAnC0BL,MAmC1B,CAA+BM,MAA/B,CAAuCD,KAAA,EAAvC,CACE,GAAuB,UAAvB,GApCwBL,MAoCpB,CAAOK,KAAP,CAAJ,CAAcG,IAAd,EAAwD,GAAxD;AApCwBR,MAoCa,CAAOK,KAAP,CAArC,CAA+CK,IAA/C,CACE,MAAA,CAGJ,MAAA,CAAO,EANkC,CATrC,GAAa,EAAb,GAAIG,KAAJ,CACE,KAAUC,MAAJ,CAAU,qDAAV,CAAN,CAEFV,KAAA,CAAQO,IAAA,CAAKC,GAAL,CAASR,KAAT,CAAgBS,KAAhB,CALyD,CAN7B,CAcjCT,KAAP,EAAe,CA7Bf,EADIW,CACJ,CADmB,CAAR,CAAAX,KAAA,CAAYJ,MAAA,CAAOI,KAAP,CAAa,CAAb,CAAZ,CAA8B,IACzC,GAAYY,KAAA,CAAMP,IAAN,CAAWM,CAAX,CAAgBL,IAAhB,CAAZ,EACEV,MAAA,CAAOiB,MAAP,CAAcb,KAAA,EAAd,CAAuB,CAAvB,CAA0Bc,OAA1B,CAEFlB,OAAA,CAAOiB,MAAP,CAAcE,KAAd,CAAoBnB,MAApB,CAA4B,CAAEI,KAAF,CAAS,CAAT,CAAA,CAAagB,MAAb,CAAoBnB,SAApB,CAA5B,CAEIoB,UAAAA,CAAMjB,KAANiB,CAAcpB,SAAdoB,CAAwBf,MACxBN,OAAA,CAAOqB,SAAP,CAAJ,EAAmB,UAAA,CAAWZ,IAAX,CAAgBT,MAAA,CAAOqB,SAAP,CAAhB,CAA4BX,IAA5B,CAAnB,EACEV,MAAA,CAAOiB,MAAP,CAAcI,SAAd,CAAmB,CAAnB,CAAsBH,OAAtB,CAEF,OAAOlB,OAdoC,CAH7C,KAAIkB,QAAU,CAAER,KAAM,IAAR,CAAcF,KAAM,YAApB,CAAd,CACIQ,MAAQ,UAJkG;",
"sources":["node_modules/glsl-token-inject-block/index.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$glsl_token_inject_block$index\"] = function(global,require,module,exports) {\nmodule.exports = glslTokenInject\n\nvar newline = { data: '\\n', type: 'whitespace' }\nvar regex = /[^\\r\\n]$/\n\nfunction glslTokenInject (tokens, newTokens) {\n  if (!Array.isArray(newTokens))\n    newTokens = [ newTokens ]\n  var start = getStartIndex(tokens)\n  var last = start > 0 ? tokens[start-1] : null\n  if (last && regex.test(last.data)) {\n    tokens.splice(start++, 0, newline)\n  }\n  tokens.splice.apply(tokens, [ start, 0 ].concat(newTokens))\n  \n  var end = start + newTokens.length\n  if (tokens[end] && /[^\\r\\n]$/.test(tokens[end].data)) {\n    tokens.splice(end, 0, newline)\n  }\n  return tokens\n}\n\nfunction getStartIndex (tokens) {\n  // determine starting index for attributes\n  var start = -1\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n    if (token.type === 'preprocessor') {\n      if (/^#(extension|version)/.test(token.data)) {\n        start = Math.max(start, i)\n      }\n    } else if (token.type === 'keyword' && token.data === 'precision') {\n      var semi = findNextSemicolon(tokens, i)\n      if (semi === -1) {\n        throw new Error('precision statement not followed by any semicolons!')\n      }\n      start = Math.max(start, semi)\n    }\n  }\n  return start + 1\n}\n\nfunction findNextSemicolon (tokens, start) {\n  for (var i = start; i < tokens.length; i++) {\n    if (tokens[i].type === 'operator' && tokens[i].data === ';') {\n      return i\n    }\n  }\n  return -1\n}\n};"],
"names":["shadow$provide","global","require","module","exports","glslTokenInject","tokens","newTokens","Array","isArray","start","i","length","token","type","test","data","Math","max","semi","Error","last","regex","splice","newline","apply","concat","end"]
}
